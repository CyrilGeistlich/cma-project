---
title: Automated Transport Mode Detection of GPS Tracking Data
author: Cyril Geistlich, Micha Franz
format: 
  html:
    code-fold: true
    toc: true
    toc_float: true
    css: style.css
    bibliography: bibtex.bib
    csl: chicago-fullnote.csl
---

<!-- You can add  your R Code with Code chunks-->

```{r}
#| echo: false
#| warning: false
#| message: false

# echo: false           hides the code from the generated output
# warning: false        hides warnings from the generated output
# message: false        hides messages from the generated output
# To apply the setting for all code chunks, add the options to the yaml header of the document (in between the ---) without the preceeding "#|".

```

## Abstract

This project aims to investigate key factors and features in GPS tracking data to differentiate transportation vehicles. Machine learning is applied to automate transportation mode detection using spatial, temporal, and attribute analysis. Manual verification of results ensures accuracy. The findings contribute to computational movement analysis and automated transportation mode detection.

## Introduction

In recent years, the spread of GPS-enabled devices and progress in location-based technologies have generated vast amounts of GPS tracking data. This data holds large significant potential for extracting insights and to improve our understanding of human mobility patterns. One main application in this field is the differentiation of transportation modes. This can benefit various domains such as traffic management or urban planning. Determining the mode of transportation from GPS tracking data presents several challenges. With the ubiquitous increase of GPS tracking through smartphones and other technical devices, it's too time consuming and expensive to manually annotate data and also prone to human error or biases. This leads to the following two research questions:

<span style="color:#007090;"> 
**What are the key factors and features that can be extracted from GPS tracking data to differentiate between different types of transportation modes?**
</span>

<span style="color:#007090;"> 
**How can machine learning techniques be applied to GPS tracking data to automate the detection of the mode of transportation and which accuracies can be achieved by different machine learning algorithms?**
</span>

The project will focus on exploring spatial and temporal aspects to extract key factors from GPS tracking data, such as velocity, sinuosity or angles. Additionally, spatial context in the form of traffic networks and land cover is added to the data in order to improve the accuracy of transportation mode detection. Machine learning algorithms will be tested and employed to automate the classification of transportation modes. An accurate algorithm is aimed to be found by training and evaluating different models on labeled data. These models include random forests, support vector machines or neural networks. To ensure the accuracy of the models, a subset of the classified data is used to validate the performance. By comparing the results of the automated classification with ground truth data, the project aims to assess the achieved accuracies of different machine learning algorithms and identify areas for improvement.

## Data & Methods

### Data

The main data are the GPS tracking data, which were recorded through the Posmos App via smartphone throughout a time span of approximately two months by the two authors. The complete collected data was manually labelled to ensure a valid ground truth. Further, spatial context data such as the Swiss road network, tram network [@swisstopo], train network [@sbb] and the bus network of the cantons of Zurich [@zvv] and Bern [@geo_bern] (Note: There is no official bus network for the entire Switzerland according to the federal bureau of transport, thus we used the available ones for Bern and Zurich, where a significant amount of data points pertaining to bus usage were collected.) To facilitate the detection of the transportation mode boat, land cover data containing all Swiss waters was also used [@swisstopo].

### Preprocessing

When tracking a person throughout the day using GPS data, there are instances where the person appears to be stationary, such as when in an office or at a university. However, due to GPS inaccuracies, these stationary points may not appear at the exact same location and can exhibit erratic movement patterns. The accuracy of GPS signals is often compromised in dense buildings, amplifying this phenomenon. As a result, parameters like velocity and step length can show values that are typically associated with other categories. To address this issue, two approaches have been employed.

The first approach involves analyzing the angles between consecutive points. Typically, these angles are significantly smaller for stationary points compared to other movements. By visually determining a threshold angle (X), the dataset is filtered to remove all data points with angles smaller than X. This process needs to be repeated iteratively until no angles below the threshold remain, as the removal of data points alters the angles between the remaining points.

The second approach considers the distance between the current point and a set number (X) of preceding and consecutive points. A point is deemed static if the maximum distance between that point and any of the X preceding or consecutive points exceeds a predefined threshold (X). However, this approach may unintentionally remove non-static data points, particularly when a person is walking slowly and numerous data points are recorded within a small distance. Adjusting the distance threshold or the number of preceding and consecutive points can mitigate this issue, but it requires striking a balance between filtering out false movements and retaining genuine data.

Finding the optimal compromise between these filtering approaches involves considering the specific characteristics of the tracked person's movements and the quality of the GPS data. By iteratively applying the angle-based filtering and analyzing the distance to surrounding points, a more accurate identification of stationary periods can be achieved, mitigating the impact of GPS inaccuracies and preserving the integrity of the tracking data.



```{r, warning = F}
library("dplyr")
library("sf")
library("readr") 
library("ggplot2")
library("mapview")
library("lubridate")
library("zoo") 
library("caret")
library("LearnGeom") # to calculate angle
library("geosphere") # to calculate distances
library("RColorBrewer") # to create custom color palettes
library("ggcorrplot") # for correlation matrix
library("ROSE")
library("gridExtra")
```

## supporting functions

```{r}
custom_mapview <- function(sf_object){
  mapview(sf_object, cex = 4, col.regions = "#700101")
}

# creates lines out of points for visualisation purposes
point2line <- function(points){
  geometries <- st_cast(st_geometry(points %>% select(geometry)), "POINT")
  n <- length(geometries) - 1
  linestrings <- lapply(X = 1:n, FUN = function(x) {

  pair <- st_combine(c(geometries[x], geometries[x + 1]))
  line <- st_cast(pair, "LINESTRING")
  return(line)
  })
  
  multilinetring <- st_multilinestring(do.call("rbind", linestrings))
  
  df <- data.frame(linestrings[1])
  
  for (i in 2:length(linestrings)){
    temp <- data.frame(linestrings[i])
    df <-  rbind(df, temp) 
  }
  sf_lines <- df %>% st_as_sf()
}

un_col <- function(df){
  return(length(unique(df)))
}
```

# 1. Data Prep

## 1.1 Read Data

```{r read tracking data}
#posmo_truth_csv <- read.delim("data/posmo_full.csv",sep=",")
posmo_micha_truth_csv <- read.delim("data/manually_labelled/posmo_20230502_to_20230613_m.csv",sep=",") 
posmo_cyril_truth_csv <- read.delim("data/manually_labelled/posmo_2023-05-01T00_00_00+02_00-2023-06-26T23_59_59+02_00.csv",sep=",") 
posmo_micha_csv <- read.delim("data/posmo_labelled/posmo_20230502_to_20230613_p.csv",sep=",") 


# From data pool
posmo_pool_1 <- read.delim("data/manually_labelled/posmo.csv",sep=",") 
posmo_pool_2 <- read.delim("data/manually_labelled/posmo_2.csv",sep=",") 
posmo_pool_3 <- read.delim("data/manually_labelled/posmo_BuJa.csv",sep=",") 

```

```{r read context data}
tram_netz <- read_sf("data/tlm_oev_eisenbahn/tlm_oev_eisenbahn_tram.shp") %>%
  select(id, geometry) %>% st_zm() %>% st_buffer(10) %>% st_union
zug_netz <- read_sf("data/tlm_oev_eisenbahn/tlm_oev_eisenbahn_bahn.shp") %>% 
  select(id, geometry) %>% st_zm() %>% st_buffer(10) %>% st_union
gewaesser <- read_sf("data/tlm_bb_gewaesser/tlm_bb_gewaesser_larger20000.shp") %>% 
  select(id, geometry) %>% st_zm() %>% st_union
strassen <- read_sf("data/tlm_strassen/strassen_AOI.shp") %>% 
  select(id, geometry) %>% st_zm() %>% st_buffer(10) %>% st_union

bus_netz_zvv <- read_sf("data/zvv_netz/Linien_des_offentlichen_Verkehrs_-OGD.gpkg", layer="ZVV_LINIEN_L")
bus_netz_zvv <- bus_netz_zvv[grepl("bus|Bus", bus_netz_zvv$BETRIEBSZWEIG_TXT), ] %>% rename(geometry = geom) %>%
  select(geometry) %>% st_buffer(10) %>% st_union()

bus_netz_bern <- read_sf("data/geoinformation_bern/OEVTP_LINIE.shp") %>% filter(VERKMITT_B == "Bus") %>% select(geometry) %>%st_zm() %>% st_buffer(10) %>% st_union()

bus_netz <- st_union(bus_netz_bern, bus_netz_zvv)
```

## 1.2.1 Clean and preprocess data

```{r preprocess data}
process_posmo_data <- function(posmo_data) { # function with preprocessing steps

  # Convert to sf object
  posmo_data <- posmo_data %>%
    st_as_sf(coords = c("lon_x", "lat_y"), crs = 4326) %>%
    st_transform(crs = 2056)
  
  # Remove unwanted columns
  posmo_data <- posmo_data[, -c(1, 3, 4)]
  
  # Fix Timestamp
  posmo_data$datetime <- ymd_hms(posmo_data$datetime) + hours(2)
  
  # Add ID to rows
  posmo_data <- posmo_data %>%
    mutate(id = row_number())
  
  # remove duplicate time values
  posmo_data <- posmo_data[!duplicated(posmo_data$datetime), ]
  
  # remove subsequent duplicate location (person wasn't moving)
  posmo_data <- posmo_data %>% 
    filter(geometry != lead(geometry))
  
  return(posmo_data)
}

# posmo_micha_truth <- process_posmo_data(posmo_micha_truth_csv)
# posmo_cyril_truth <- process_posmo_data(posmo_cyril_truth_csv)
# posmo_micha <-  process_posmo_data(posmo_micha_csv)
```

```{r working datasets}
# micha_subset <- posmo_micha_truth %>% filter(datetime < ymd("20230506") & datetime > ymd("20230501"))
# 
# working_dataset <- posmo_micha_truth
```

### 1.2.2 Remove static data points

```{r function to filter static points using moving distance}
filterStaticByDistance <- function(data, threshold_distance, consecutive_points) {
  require(geosphere)
  
  # transform to WGS84, necessary to calculate distance using geosphere
  data <- data %>% st_transform(4326)
  
  # Extract coordinates from the geometry
  coords <- data.frame(st_coordinates(data))
  data$longitude <- coords$X
  data$latitude <- coords$Y
  
  # Calculate distances to preceding and consecutive points
  distances <- numeric(nrow(data))
  for (i in (consecutive_points + 1):(nrow(data) - consecutive_points)) {
    next_points <- coords[(i + 1):(i + consecutive_points), ]
    prev_points <- coords[(i - 1):(i - consecutive_points), ]
    all_points <- rbind(next_points, prev_points)
    distances[i] <- max(geosphere::distGeo(coords[i, ], all_points))
  }
  
  # Filter out points where the maximum distance exceeds the threshold
  filtered_data <- data[distances >= threshold_distance | distances == 0, ] # keep first/last values which are 0
  
  # Transform back to LV95
  filtered_data <- filtered_data %>% st_transform(2056)
  
  return(list(filtered_data = filtered_data, distances = distances)) # distances are just needed for testing thresholds
}
```

```{r Function to calculate angle }
getAngle <- function(coords) {
  angles <- numeric(nrow(coords)) # Initialize angles as a numeric vector
  angles[1] = NA # first point can't have an angle

  for (i in 2:(nrow(coords) - 1)) { # calculate the angle for 3 consecutive points, similar to lag/lead
    angle <- Angle( #function from library LearnGeom
      c(coords[i - 1, "X"], coords[i - 1, "Y"]),
      c(coords[i, "X"], coords[i, "Y"]),
      c(coords[i + 1, "X"], coords[i + 1, "Y"])
    )
    angles[i] <- angle # Assign the calculated angle to the corresponding index in angles
  }
  angles[nrow(coords)] = NA # last point cant have an angle
  return(c(angles))
}
```

```{r function to remove static points by angle}
filterStaticByAngle <- function(working_dataset, angleTreshold){
  coords <- data.frame(st_coordinates(working_dataset), working_dataset$id)  
  working_dataset$angle <- getAngle(coords)
  min_angle <- min(working_dataset$angle, na.rm = T)


  while (min_angle <= angleTreshold) { # iteratively filter out tight angles until none smaller 60 are left
    working_dataset <- working_dataset %>% filter(is.na(angle) | angle > angleTreshold) # exclude first and last value (=NA)
    coords <- data.frame(st_coordinates(working_dataset), working_dataset$id)
    working_dataset$angle <- getAngle(coords)
    min_angle <- min(working_dataset$angle, na.rm = T)
  }
  return(working_dataset)
}
```

```{r Actual removal of static points}

# result <- filterStaticByDistance(working_dataset, threshold_distance = 60, consecutive_points = 5)
# filteredByDistance <- result$filtered_data
# working_dataset$distances <- result$distances # just for testing threshold values
# filteredByAngle <- filterStaticByAngle(working_dataset, 60)
# filtertedByDistance_and_Angle <- filterStaticByAngle(filteredByDistance, 60)
```

```{r Visualistion of angle removal}
# filtered_data_line <- point2line(filtertedByDistance_and_Angle)
# filtered_angle_line <- point2line(filteredByAngle)
# unfiltered_data_line <- point2line(working_dataset)
# 
# pal_blue <- colorRampPalette(c("cyan", "blue"))
# pal_orng <- colorRampPalette(c("yellow", "red"))
# 
# 
# mapview(working_dataset, alpha.regions=1.0, col.regions = "#901010") +
#   mapview(unfiltered_data_line, color="#901010", lwd=2) +
#   mapview(filtertedByDistance_and_Angle, alpha.regions=1.0, col.regions="#008940") +
#   mapview(filtered_data_line, color="#008940", lwd=2) 
# 
# 
# mapview(working_dataset, alpha.regions=1.0, col.regions = "#901010", cex=4) +
#   mapview(unfiltered_data_line, color="#901010", lwd=2) +
#   mapview(filteredByAngle, alpha.regions=1.0, col.regions="orange", cex=4) +
#   mapview(filtered_angle_line, color="orange", lwd=2) 
# 
# mapview(filtered_data_line, color="#008940", lwd=2) +
#   mapview(unfiltered_data_line, color="#901010", lwd=2)
  
```

## 1.3 Segmentation?

## 1.4 Calculate Movement Parameters

### 1.4.1 Speed/ Additional Moving Window Speed?

```{r Calc Diff_s, steplength, velocity , warning = F}


calc_movement_params <- function(working_dataset){

  # Create Coord Column
  coords <- data.frame(st_coordinates(working_dataset), working_dataset$id)

  # Calculate Time Difference between steps (diff_s), steplenght and velocity. 
  working_dataset <- working_dataset |> 
  mutate(diff_s = as.numeric(difftime(lead(datetime),datetime))) |>
  mutate(steplength = ((coords$X - lead(coords$X))^2 + (coords$Y - lead(coords$Y))^2)^0.5) |>
  mutate(velocity = as.numeric(steplength/diff_s)) |>
  filter(diff_s != 0)

  coords <- data.frame(st_coordinates(working_dataset), working_dataset$id)
  
  #Calculate Moving Window Step length
  working_dataset <- working_dataset |>
  mutate(
    step_mean = rowMeans(
      cbind(
        sqrt((lag(coords$X, 3) - coords$X)^2 + (lag(coords$Y, 3) - coords$Y)^2),
        sqrt((lag(coords$X, 2) - coords$X)^2 + (lag(coords$Y, 2) - coords$Y)^2),
        sqrt((lag(coords$X, 1) - coords$X)^2 + (lag(coords$Y, 1) - coords$Y)^2),
        sqrt((coords$X - lead(coords$X, 1))^2 + (coords$Y - lead(coords$Y, 1))^2),
        sqrt((coords$X - lead(coords$X, 2))^2 + (coords$Y - lead(coords$Y, 2))^2),
        sqrt((coords$X - lead(coords$X, 3))^2 + (coords$Y - lead(coords$Y, 3))^2)
      )
    )
  )
  
  
  #Calculate Moving Window diff_s
  working_dataset <- working_dataset |>
  mutate(diff_s_mean = as.numeric(difftime(lead(datetime,3),lag(datetime,3)))/6)

  #Calculate Moving Window velocity
  working_dataset <- working_dataset |>
  mutate(velocity_mean = as.numeric(step_mean/diff_s_mean))
 
  # Delete Infitinte Values (is there better solution?)
  #working_dataset$velocity <- working_dataset$velocity[!is.infinite(working_dataset$velocity)]
  coords <- data.frame(st_coordinates(working_dataset), working_dataset$id)

  #Acceleration stepwise
  working_dataset$acceleration <- working_dataset$velocity/lag(working_dataset$diff_s)

  # Calculate acceleration using a moving window
  working_dataset <- working_dataset |>
  mutate(
    acceleration_mean = rowMeans(
      cbind(
        lag(working_dataset$acceleration,3),
        lag(working_dataset$acceleration,2),
        lag(working_dataset$acceleration,1),
        working_dataset$acceleration,
        lead(working_dataset$acceleration,1),
        lead(working_dataset$acceleration,2),
        lead(working_dataset$acceleration,3)
      )
    )
  )
  
  # Calculate Sinuosity using moving step_mean as path length and euclidean distance between
  working_dataset <- working_dataset |>
  mutate(
    sinuosity = 
      ( # Path Length/Direct distance between first and last point
        sqrt((lag(coords$X, 3) - lag(coords$X, 2))^2 + (lag(coords$Y, 3) - lag(coords$Y, 2))^2) +
        sqrt((lag(coords$X, 2) - lag(coords$X, 1))^2 + (lag(coords$Y, 2) - lag(coords$Y, 1))^2) +
        sqrt((lag(coords$X, 1) - coords$X)^2 + (lag(coords$Y, 1) - coords$Y)^2) +
        sqrt((coords$X - lead(coords$X, 1))^2 + (coords$Y - lead(coords$Y, 1))^2) +
        sqrt((lead(coords$X, 1) - lead(coords$X, 2))^2 + (lead(coords$Y, 1) - lead(coords$Y, 2))^2) +
        sqrt((lead(coords$X, 2) - lead(coords$X, 3))^2 + (lead(coords$Y, 2) - lead(coords$Y, 3))^2)
      ) 
      / sqrt((lag(coords$X, 3) - lead(coords$X, 3))^2 + (lag(coords$Y, 3) - lead(coords$Y, 3))^2)
  ) 

  return(working_dataset)
}


```

```{r run all function}


run_all <- function(df){
  df <- process_posmo_data(df)
  result <- filterStaticByDistance(df, threshold_distance = 60, consecutive_points = 5)
  result$filtered_data
  filtered_by_angle <- filterStaticByAngle(result$filtered_data, 60)
  df <- calc_movement_params(filtered_by_angle)
  return(df)
}

```

```{r combine data}

working_dataset <- run_all(posmo_micha_truth_csv)
processed_1 <- run_all(posmo_cyril_truth_csv)
processed_2 <- run_all(posmo_pool_1)
processed_3 <- run_all(posmo_pool_2)
processed_4 <- run_all(posmo_pool_3)

# Combine data sets
working_dataset <- rbind(working_dataset, processed_1)
posmo_pool <- rbind(processed_2,processed_3,processed_4)



```

### 1.4.5 Closeness to Traffic Network and Water Bodies

```{r}
data_AOI <- st_buffer(working_dataset, 50) %>% st_union()

tram_netz_AOI <- st_intersection(tram_netz, data_AOI)
working_dataset$distance_tram <- as.numeric(st_distance(working_dataset, tram_netz_AOI))
working_dataset$distance_tram <- ifelse(working_dataset$distance_tram > 100, 100, working_dataset$distance_tram)


zug_netz_AOI <- st_intersection(zug_netz, data_AOI)
working_dataset$distance_zug <- as.numeric(st_distance(working_dataset, zug_netz_AOI))
working_dataset$distance_zug <- ifelse(working_dataset$distance_zug > 100, 100, working_dataset$distance_zug)


gewaesser_AOI <- st_intersection(gewaesser, data_AOI)
working_dataset$distance_gewaesser <- as.numeric(st_distance(working_dataset, gewaesser_AOI))
working_dataset$distance_gewaesser <- ifelse(working_dataset$distance_gewaesser > 100, 100, working_dataset$distance_gewaesser)


bus_netz_AOI <- st_intersection(bus_netz, data_AOI)
working_dataset$distance_bus <- as.numeric(st_distance(working_dataset, bus_netz_AOI))
working_dataset$distance_bus <- ifelse(working_dataset$distance_bus > 100, 100, working_dataset$distance_bus)


working_dataset$distance_strasse <- as.numeric(st_distance(working_dataset, strassen))
working_dataset$distance_strasse <- ifelse(working_dataset$distance_strasse > 100, 100, working_dataset$distance_strasse)
```

```{r}
data_AOI <- st_buffer(posmo_pool, 50) %>% st_union()

tram_netz_AOI <- st_intersection(tram_netz, data_AOI)
posmo_pool$distance_tram <- as.numeric(st_distance(posmo_pool, tram_netz_AOI))
posmo_pool$distance_tram <- ifelse(posmo_pool$distance_tram > 100, 100, posmo_pool$distance_tram)


zug_netz_AOI <- st_intersection(zug_netz, data_AOI)
posmo_pool$distance_zug <- as.numeric(st_distance(posmo_pool, zug_netz_AOI))
posmo_pool$distance_zug <- ifelse(posmo_pool$distance_zug > 100, 100, posmo_pool$distance_zug)


gewaesser_AOI <- st_intersection(gewaesser, data_AOI)
posmo_pool$distance_gewaesser <- as.numeric(st_distance(posmo_pool, gewaesser_AOI))
posmo_pool$distance_gewaesser <- ifelse(posmo_pool$distance_gewaesser > 100, 100, posmo_pool$distance_gewaesser)


bus_netz_AOI <- st_intersection(bus_netz, data_AOI)
posmo_pool$distance_bus <- as.numeric(st_distance(posmo_pool, bus_netz_AOI))
posmo_pool$distance_bus <- ifelse(posmo_pool$distance_bus > 100, 100, posmo_pool$distance_bus)


posmo_pool$distance_strasse <- as.numeric(st_distance(posmo_pool, strassen))
posmo_pool$distance_strasse <- ifelse(posmo_pool$distance_strasse > 100, 100, posmo_pool$distance_strasse)
```

### 1.4.6 Slope?

### 1.4.7 Average Distance between points in section

### Further Parameters!

## Clean Data

```{r}
# Replace NA values with a specified value (e.g., mean, median, or 0)

working_dataset$sinuosity[is.infinite(working_dataset$sinuosity)] <- NA
working_dataset <- na.omit(working_dataset)

posmo_pool$sinuosity[is.infinite(posmo_pool$sinuosity)] <- NA
posmo_pool <- na.omit(posmo_pool)

velocity_plot <- ggplot(working_dataset, aes(id,velocity)) +
  geom_point() +
  ylab("velocity [m/s]")

acceleration_plot <- ggplot(working_dataset, aes(id,acceleration)) +
  geom_point() +
  ylab("acceleration [m/s2]")

sinuosity_plot <- ggplot(working_dataset, aes(id,sinuosity)) +
  geom_point()

velocity_plot
acceleration_plot
sinuosity_plot

# ggsave("plots/velocity_plot.png", plot = velocity_plot, width = 8, height = 6, dpi = 300)
# ggsave("plots/acceleration_plot.png", plot = acceleration_plot, width = 8, height = 6, dpi = 300)
# ggsave("plots/sinuosity_plot.png", plot = sinuosity_plot, width = 8, height = 6, dpi = 300)
```

```{r}
working_dataset_copy <- working_dataset
```

# 2.PCA?

```{r}
# select columns with relevant variable and standardize them
standardized <- working_dataset_copy[, 6:15] %>% 
  st_drop_geometry() %>%
  scale(center = TRUE, scale = TRUE) %>%
  as.data.frame()


corr_matrix <- cor(standardized)
ggcorrplot(corr_matrix)

data_pca <- princomp(corr_matrix)

test <- data_pca$loadings

scores <- as.data.frame(data_pca$scores)
```

```{r}
# Save full dataset as csv
working_dataset <- st_drop_geometry(working_dataset)
posmo_pool <- st_drop_geometry(posmo_pool)

write.csv(working_dataset, file = "data/full_working_dataset.csv", row.names = F)
write.csv(posmo_pool, file = "data/full_posmo_pool_dataset.csv", row.names = F)
```

## Results

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce semper maximus urna, ut aliquet massa hendrerit sed. Ut sed nisi non tellus placerat lacinia vitae nec ipsum. Nulla ut nisl non ex auctor pharetra. In efficitur mi non nibh malesuada, eu dapibus est cursus. Nulla feugiat nisi metus, eget laoreet elit congue non. Nam et mauris sed leo tincidunt fermentum ac at leo. Morbi tincidunt vestibulum turpis, nec consectetur dolor placerat a. Integer dapibus, est sit amet tincidunt pellentesque, elit elit sagittis erat, nec rutrum est nunc ut libero.

Phasellus lobortis purus eu purus fermentum, vitae mattis nunc malesuada. Aliquam semper mauris eget nisl fringilla, eget feugiat nulla viverra. Vestibulum vestibulum nisi a purus pellentesque, et tincidunt nisl pulvinar. Mauris id rutrum lorem. Etiam cursus efficitur nisl, vel finibus turpis aliquam ac. Cras in est sit amet tortor tincidunt efficitur. Maecenas ac est bibendum, pharetra neque a, consectetur nisi. Maecenas ultrices ultricies ipsum id ullamcorper. Donec fringilla sem eu tortor dictum ullamcorper.

Vestibulum varius nunc et eleifend sollicitudin. Maecenas facilisis urna quis sapien bibendum, et gravida sem rutrum. Nam accumsan tortor sit amet turpis dapibus, et varius ligula pharetra. Mauris consectetur, arcu auctor ullamcorper finibus, justo massa convallis purus, in eleifend lectus felis in odio. Sed efficitur mi ac felis facilisis aliquam. Aliquam consequat sem ut augue vulputate viverra. In nec fringilla sapien. Donec sit amet pharetra turpis. Curabitur vel tellus sed odio ultrices volutpat a at lacus.

Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Curabitur placerat dui ut vestibulum malesuada. Duis lobortis ipsum a commodo tincidunt. Fusce eu elit id risus dapibus feugiat. Vivamus eget fringilla nisl. Nullam suscipit massa ut dapibus efficitur. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Aliquam nec diam rutrum, pulvinar libero sit amet, viverra justo. Sed efficitur magna eget risus luctus, vel feugiat quam varius. Morbi finibus justo nec ex semper, ut gravida mauris vulputate.

Nullam mollis elementum metus ac congue. Fusce porttitor sem quis augue fermentum, id tempus leo bibendum. Nam malesuada justo quis consectetur tristique. Nullam ullamcorper enim ut faucibus aliquam. Donec et purus urna. Pellentesque sed neque elit. Mauris commodo dui eget dui tempor dictum. Nulla facilisi. Quisque venenatis sollicitudin est, vel tristique lacus gravida ac. Sed vehicula nibh id libero commodo interdum.

## Discussion
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce semper maximus urna, ut aliquet massa hendrerit sed. Ut sed nisi non tellus placerat lacinia vitae nec ipsum. Nulla ut nisl non ex auctor pharetra. In efficitur mi non nibh malesuada, eu dapibus est cursus. Nulla feugiat nisi metus, eget laoreet elit congue non. Nam et mauris sed leo tincidunt fermentum ac at leo. Morbi tincidunt vestibulum turpis, nec consectetur dolor placerat a. Integer dapibus, est sit amet tincidunt pellentesque, elit elit sagittis erat, nec rutrum est nunc ut libero.

Phasellus lobortis purus eu purus fermentum, vitae mattis nunc malesuada. Aliquam semper mauris eget nisl fringilla, eget feugiat nulla viverra. Vestibulum vestibulum nisi a purus pellentesque, et tincidunt nisl pulvinar. Mauris id rutrum lorem. Etiam cursus efficitur nisl, vel finibus turpis aliquam ac. Cras in est sit amet tortor tincidunt efficitur. Maecenas ac est bibendum, pharetra neque a, consectetur nisi. Maecenas ultrices ultricies ipsum id ullamcorper. Donec fringilla sem eu tortor dictum ullamcorper.

Vestibulum varius nunc et eleifend sollicitudin. Maecenas facilisis urna quis sapien bibendum, et gravida sem rutrum. Nam accumsan tortor sit amet turpis dapibus, et varius ligula pharetra. Mauris consectetur, arcu auctor ullamcorper finibus, justo massa convallis purus, in eleifend lectus felis in odio. Sed efficitur mi ac felis facilisis aliquam. Aliquam consequat sem ut augue vulputate viverra. In nec fringilla sapien. Donec sit amet pharetra turpis. Curabitur vel tellus sed odio ultrices volutpat a at lacus.

Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Curabitur placerat dui ut vestibulum malesuada. Duis lobortis ipsum a commodo tincidunt. Fusce eu elit id risus dapibus feugiat. Vivamus eget fringilla nisl. Nullam suscipit massa ut dapibus efficitur. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Aliquam nec diam rutrum, pulvinar libero sit amet, viverra justo. Sed efficitur magna eget risus luctus, vel feugiat quam varius. Morbi finibus justo nec ex semper, ut gravida mauris vulputate.

Nullam mollis elementum metus ac congue. Fusce porttitor sem quis augue fermentum, id tempus leo bibendum. Nam malesuada justo quis consectetur tristique. Nullam ullamcorper enim ut faucibus aliquam. Donec et purus urna. Pellentesque sed neque elit. Mauris commodo dui eget dui tempor dictum. Nulla facilisi. Quisque venenatis sollicitudin est, vel tristique lacus gravida ac. Sed vehicula nibh id libero commodo interdum.

# References